[
	{
		"tool_id": "UB116GYDoetyOQNHLnwR0I2mvkqXNyHVTWfPF123vnGguvVC116Nj3esa3Jp4ciLYGs123W116U2SNZoNUquKnbCpNUu4b4A117117",
		"name": "ALPS - Application-Level Profile Semantics",
		"user": "",
		"details": "The purpose of Application-Level Profile Semantics (ALPS) is to document the application-level semantics of a particular implementation. This is accomplished by describing elements of response representations for a target media type. For example identifying markup elements returned (i.e. semantic HTML ala Microformats) and state transitions (i.e. HTML.A and HTML.FORM elements) that advance the state of the current application.",
		"post_date": "2014-04-02 16:40:11",
		"url": "http://amundsen.com/hypermedia/profiles/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/alps-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Semantics",
			"Definitions"
		]
	},
	{
		"tool_id": "123KEubtan6h5rv5VY116MP123123PiGxuZKxil2E076G123Fy8aG2zUkWekjk8YWSgaakJlHMruIMfRdSRcJZYGvMVjg3ng117117",
		"name": "API Blueprint",
		"user": "apiaryio",
		"details": "API Blueprint is a documentation-oriented API description language. A couple of semantic assumptions over the plain Markdown. API Blueprint is perfect for designing your Web API and its comprehensive documentation but also for quick prototyping and collaboration. It is easy to learn and even easier to read &ndash; after all it is just a form of plain text. API Blueprint, its parser, and most of its tools are completely open sourced so you dont have to worry about vendor lock-in. This also means you can freely integrate API Blueprint into any type of product, commercial or not.",
		"post_date": "2015-05-14 12:42:22",
		"url": "https://github.com/apiaryio/api-blueprint/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png",
		"forks": "629",
		"followers": "2155",
		"watchers": "2155",
		"tags": [
			"Specification",
			"Design",
			"Definitions",
			"API Blueprint Core",
			"API Blueprint"
		]
	},
	{
		"tool_id": "DYbI4KEKr5Nx0E5SNLPBCCz9P74XahwWGu5VyoLq8k11677AsjKOe9d116oZL1IfPZv70Zb0duHxbfd1rZb5z4Rz8Q117117",
		"name": "Apiary Blueprint Parser",
		"user": "",
		"details": "A JavaScript parser of&nbsp;Apiary API blueprints. Uses Node.js then in browser, include the browser version of the parser in your web page or application using the &lt;script&gt; tag. To parse an API blueprint, just call the parse method and pass the blueprint as a parameter. The method will return an object representing the parsed blueprint or throw an exception if the input is invalid.",
		"post_date": "2013-06-12 18:42:12",
		"url": "https://github.com/apiaryio/blueprint-parser",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Parser",
			"Definitions",
			"API Blueprint"
		]
	},
	{
		"tool_id": "G65WDT7O116kf6R5Wbz0UIEv3c61z116xCJ9Ff3wqjuWCwCemVLXfJWc116ybfgnMWqpfzoOPsN4XB6116fJaco0cQbPsA117117",
		"name": "APIs.json",
		"user": "",
		"details": "APIs are becoming a crucial part of the Web. Unfortunately however, it remains very difficult to determine the location of these APIs on servers around the Web. The only way to discover APIs and their properties is via human driven search through public search engines or in hand curated API Directory listings. While these methods work, neither can scale to the potentially hundreds of thousands and millions of APIs which will be published over the next few years.",
		"post_date": "2014-06-15 17:00:37",
		"url": "http://apisjson.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/apisdotjson.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Discovery",
			"Definitions"
		]
	},
	{
		"tool_id": "aiQ8kH4Rqvw3jw8fSrMi8pTgkvs7MnFysioRZ0uo0f1klPBKoqcMC116zZzQRXH7Gd1JzzB2eSmB0KWTkVFHz1166A117117",
		"name": "Barrister RPC",
		"user": "",
		"details": "Barrister is a RPC system that uses an external interface definition (IDL) file to describe the interfaces and data structures that a component implements. It is similar to tools like Protocol Buffers, Thrift, Avro, and SOAP.",
		"post_date": "2015-07-30 23:36:22",
		"url": "http://barrister.bitmechanic.com/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/barrister-rpc.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "123wJlc116jjvqsV3SHE6DBcci52uyXGlFJ737MSvSINji6IU2O7VSH3OkR81wla3Ga1qeMOx4NgnORQV5szoF9116wg117117",
		"name": "Collection+JSON",
		"user": "",
		"details": "Collection+JSON is a JSON-based read/write hypermedia-type designed to support management and querying of simple collections.",
		"post_date": "2014-07-25 18:07:45",
		"url": "http://amundsen.com/media-types/collection/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "https://github.com/collection-json",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "MTtFiPBDgtoqzugDEJUBWdDz8uAbHg6MSAPBa4ryRygrrtP0a123MlurRAIV5LTg0soS0LR2y4WiZaVleoX6IWBg117117",
		"name": "HAL",
		"user": "",
		"details": "HAL is a simple format that gives a consistent and easy way to hyperlink between resources in your API. Adopting HAL will make your API explorable, and its documentation easily discoverable from within the API itself. In short, it will make your API easier to work with and therefore more attractive to client developers. APIs that adopt HAL can be easily served and consumed using open source libraries available for most major programming languages. Its also simple enough that you can just deal with it as you would any other JSON.",
		"post_date": "2014-07-25 17:27:37",
		"url": "http://stateless.co/hal_specification.html",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/bw-github.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "85280YOaZtaFJZ6S5idf1QtduuX2Gg1rotNCBUzq6xGZ285aeopIQZ51hcBcrK116LYkH4WbfUxdrCddqP6p0NsQ117117",
		"name": "Home Documents for HTTP APIs",
		"user": "",
		"details": "JSON Home Document is an HTTP API definition formated that follows the RFC4627 specification, and has the media type application/json-home.",
		"post_date": "2015-07-30 19:12:17",
		"url": "http://tools.ietf.org/html/draft-nottingham-json-home-02",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/ietf-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "Xa7CKO5Qb116sRFhHNHdpr03el9sJAp0cCsmuqvPiCQazpmG1KoluIfOf0vfwMvscVRUrzo4mQ6WzglaeEU8DsHg117117",
		"name": "I/O Docs",
		"user": "",
		"details": "I/O Docs is a live interactive documentation system for RESTful web APIs. By defining APIs at the resource, method and parameter levels in a JSON schema, I/O Docs will generate a JavaScript client interface. API calls can be executed from this interface, which are then proxied through the I/O Docs server with payload data cleanly formatted (pretty-printed if JSON or XML).",
		"post_date": "2013-02-02 20:12:13",
		"url": "https://github.com/mashery/iodocs",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/io-docs-logo.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Definitions"
		]
	},
	{
		"tool_id": "9gX7JikJblzfmuD50DXX62ooasa35k0vccjVKSvsIM2116D8bQ0ouU5525cci116Ad6NBvZ2CaFo6e3PP5sfnsH123PA117117",
		"name": "Interpol",
		"user": "",
		"details": "Interpol is a toolkit for policing your HTTP JSON interface. To use it, define the endpoints of your HTTP API in simple YAML files. Interpol provides multiple tools to work with endpoint definitions.",
		"post_date": "2015-07-30 23:38:45",
		"url": "https://github.com/seomoz/interpol",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/interpol-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "12jXk6ZDKDfZka9wOWD19SzCRtJdoatHS8sOjWhGMqLVIkQ30obdpMCgp116Zgge3RxO123FF2C123EUMarJcJFzPU6Q117117",
		"name": "JSON API",
		"user": "",
		"details": "If youve ever argued with your team about the way your JSON responses should be formatted, JSON API is your anti-bikeshedding weapon. By following shared conventions, you can increase productivity, take advantage of generalized tooling, and focus on what matters: your application. Clients built around JSON API are able to take advantage of its features around efficiently caching responses, sometimes eliminating network requests entirely.",
		"post_date": "2015-07-10 18:54:07",
		"url": "http://jsonapi.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-api-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Media Type",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "IaucsN21piqRpJJtAsoURUBkHzV5ubbFXH9Qe2eEBhz9iDEhtjr1230az6pLRFtNJmF2jRUhfEWiltQNLPWvOiJQ117117",
		"name": "JSON Schema",
		"user": "",
		"details": "Describes your JSON data format in clear, human- and machine-readable documentation that is complete structural validation, useful for automated testing, and validating client-submitted data.",
		"post_date": "2015-07-30 23:49:15",
		"url": "http://json-schema.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-schema.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Definitions",
			"Data Specifications"
		]
	},
	{
		"tool_id": "vJW7zflD7MQBkvtcmtIHllMUeB4jqbYimuuIwJpnwVDDQLAS2vEOrVdMZcKvxJenjA1pjcWKalcC5116Y5NL6cQg117117",
		"name": "JSON-LD",
		"user": "",
		"details": "JSON-LD is a lightweight Linked Data format. It is easy for humans to read and write. It is based on the already successful JSON format and provides a way to help JSON data interoperate at Web-scale. JSON-LD is an ideal data format for programming environments, REST Web services, and unstructured databases such as CouchDB and MongoDB.",
		"post_date": "2014-12-19 10:57:24",
		"url": "http://json-ld.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/json-ld.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Semantics",
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "RjFqmaiyGP6ruHy116ZklOLQQnsxvMnSS8cwp66yIJI1mS60r7FOMckVKOnV8VNVKlB5C6MSbjdX9QYxe1FDz9tw117117",
		"name": "JSON-RPC 2.0",
		"user": "",
		"details": "JSON-RPC is a stateless, light-weight remote procedure call (RPC) protocol. Primarily this specification defines several data structures and the rules around their processing. It is transport agnostic in that the concepts can be used within the same process, over sockets, over http, or in many various message passing environments. It uses JSON (RFC 4627) as data format.",
		"post_date": "2015-07-30 23:53:52",
		"url": "http://www.jsonrpc.org/specification",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/json-rpc.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Definitions",
			"Data Specifications"
		]
	},
	{
		"tool_id": "JHcQJNL3GhQAYRJpZ308SGFncGm4XCT1tZbR0r9hAxKkVcv4KGITT8D1237KzP4crwds116vtjQBeU1164kLXaWOsj1A117117",
		"name": "Markdown Syntax for Object Notation",
		"user": "",
		"details": "MSON is a plain-text, human and machine readable, description format for describing data structures in common markup formats such as JSON, XML or YAML.",
		"post_date": "2015-07-30 23:40:36",
		"url": "https://github.com/apiaryio/mson",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Definitions",
			"Data Specifications"
		]
	},
	{
		"tool_id": "WAfIg8637yn8mZXAMqCYg25BvkMqbXzdClCqd1w116agA2M5N9Lu2OyhqjWzqvcfHB6aLwmq123rTrozY5p4RMI8TQ117117",
		"name": "Mason",
		"user": "",
		"details": "Mason is a JSON format for introducing hypermedia elements to classic JSON data representations. With Mason you get hypermedia elements for linking and modifying data, features for communicating to client developers and standardized error handling. Mason is built on JSON, reads JSON, writes JSON and generally fits well into a JSON based eco-system.",
		"post_date": "2014-12-19 10:59:17",
		"url": "https://github.com/JornWildt/Mason",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/jorn-wildt.jpeg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "4LNYveq21gLld15eIZhmDhoGpn5YzDliVV3zSdXGVAe5v6HOAtJRewOcg3eCRhfoM0mIiXE1LCd4wWtaxDxftg117117",
		"name": "Open Data Protocol (OData)",
		"user": "",
		"details": "OData (Open Data Protocol) is an OASIS standard that defines the best practice for building and consuming RESTful APIs. OData helps you focus on your business logic while building RESTful APIs without having to worry about the approaches to define request and response headers, status codes, HTTP methods, URL conventions, media types, payload formats and query options etc.",
		"post_date": "2015-07-30 22:03:30",
		"url": "http://www.odata.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/odata-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Design",
			"Definitions",
			"Data Specification"
		]
	},
	{
		"tool_id": "SwNxHJWgQiR6e9bt4Xm1WAe9s1JE529AP5tSPMiwa3fQXVBmuxg5pLOmPDU2QCEAKtBQ116SZaj6u3tHCAazP8jw117117",
		"name": "OpenAPI Specification",
		"user": "OAI",
		"details": "The OpenAPI Specification Repository",
		"post_date": "2016-03-11 23:16:54",
		"url": "https://github.com/OAI/OpenAPI-Specification",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/openapi-spec.png",
		"forks": "940",
		"followers": "3107",
		"watchers": "3107",
		"tags": [
			"GitHub",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "N6dYL123IzqO6tXSyiIOR3hWVKLLmolHANR123fRKn6YEGS5beHHWF5eivoQkzGboPQHwBAxAjJAPXor2BQ64ANlWw117117",
		"name": "Paw API Blueprint Generator",
		"user": "apiaryio",
		"details": "Paw extension providing support to export API Blueprint as a code generator.",
		"post_date": "2015-05-14 12:45:02",
		"url": "https://github.com/apiaryio/Paw-APIBlueprintGenerator/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/paw-api-client.png",
		"forks": "1",
		"followers": "10",
		"watchers": "10",
		"tags": [
			"Generator",
			"Definitions",
			"Client",
			"API Blueprint"
		]
	},
	{
		"tool_id": "UVg0ZUeLGbwoigjtPQs6fC116NR116khLaqXuf9QHy116QKYEBsF49g116Xf2HZ1m6MbbKzWNdEuEY9FKms4DI3YVG7m4A117117",
		"name": "Postman Collections",
		"user": "",
		"details": "A collection lets you group individual requests together. These requests can be further organized into folders to accurately mirror your API. Requests can also store sample responses when saved in a collection. You can add metadata like name and description too so that all the information that a developer needs to use your API is available easily.",
		"post_date": "2015-07-30 23:44:35",
		"url": "https://www.getpostman.com/docs/collections",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/postman-rest-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Definitions"
		]
	},
	{
		"tool_id": "Hvof3w4XF1beSuFuKslQ2y10WGbQ0U06JtYvWP30yvW917PcENQFxhyc9n9RyS3TH3cfIhpUKc74gEi4CBPUgQ117117",
		"name": "RAML Specification",
		"user": "",
		"details": "RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.",
		"post_date": "2015-06-30 14:05:03",
		"url": "http://raml.org",
		"blog_url": "http://blog.raml.org/",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/raml-logo.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"RAML",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "OeiX4a2gxt2K12gimiOfETcpsTI03QSaCj9tfMzyDlb7436CzzlG3116TmoYu4dp9Md1WubwPAA123yMFmwBaPPd6g117117",
		"name": "RESTdesc",
		"user": "",
		"details": "Semantic descriptions for hypermedia APIs. RESTdesc allows you to capture the functionality of hypermedia APIs, so automated agents can use them. Despite their powerful capabilities, RESTdesc descriptions are easy to master. Description is not a goal in itself: you want your API to be used. See how RESTdesc opens up your API for discovery, based on its functional characteristics.",
		"post_date": "2015-07-31 00:00:13",
		"url": "http://restdesc.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/restdesc-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "tAGvGx5j9lyhMw0o7v4MLROMRaDN2WpfNHgrqqY7X2fE07NlnqXlDAHslfAxgQtjw21tma8WReIc123jPbJOJ9123Q117117",
		"name": "RESTful API Description Language (RADL)",
		"user": "",
		"details": "RESTful API Description Language (RADL) is an XML vocabulary for describing Hypermedia-driven RESTful APIs. Unlike most HTTP API description languages, RADL focuses on defining a truly hypermedia-driven REST API from the clients point of view. Unlike description languages based on JSON or Markdown, RADL makes it easy to integrate documentation written in HTML or XML. The APIs that RADL describes may use any media type, in XML, JSON, HTML, or any other format.",
		"post_date": "2015-07-11 16:49:06",
		"url": "https://github.com/restful-api-description-language/RADL",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/radl-logo.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "12kxiXXSnv116Cl9cn116BB6vPI6qmCb6pQA9CScee116SB4O3L3Lrer1APq9P8ieKtrdg8VlXzH08VwBHLF22BVp4ww117117",
		"name": "RESTful API Modeling Language",
		"user": "",
		"details": "RESTful API Modeling Language (RAML) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.",
		"post_date": "2013-12-22 23:45:15",
		"url": "http://raml.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Definitions"
		]
	},
	{
		"tool_id": "iK1FRMQQa7cfzWVIOSTPuxoWW0xDyaosvRqyxqaxZB2r8hykwmY47123Smm74wR4XJJr1235bSHlJglALrjzMeX7kw117117",
		"name": "RESTful Service Description Language (RSDL)",
		"user": "",
		"details": "The RESTful Service Description Language (RSDL) is a machine- and human-readable XML description of HTTP-based web applications (typically REST web services).",
		"post_date": "2015-07-30 23:12:42",
		"url": "http://www.balisage.net/Proceedings/vol10/html/Robie01/BalisageVol10-Robie01.html",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/rsdl-icon.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "OcvweWajvcYNRJndT1fR3123BpE116bXZp4l5116DDRJiUnUEsxUyR3123uIwRvqS2U6l9g116Mx4VFmwRDq0xVV2hO8pbnQ117117",
		"name": "Rspec APIBlueprint",
		"user": "",
		"details": "Autogeneration of API documentation using the Blueprint format from request specs.",
		"post_date": "2014-06-15 13:13:42",
		"url": "https://github.com/playround/rspec_api_blueprint",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/api-blueprint.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Generator",
			"Generation",
			"Definitions"
		]
	},
	{
		"tool_id": "8ZKvLX2dlnwdAky0zKg2jjSGI3MmIfk0ZNT8lLqAWBm7LKQtvdM581161zRC1FsUZ1o7M116yqvH5h123nyx5tUMkZSg117117",
		"name": "Schema.org",
		"user": "",
		"details": "Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet, on web pages, in email messages, and beyond. Schema.org vocabulary can be used with many different encodings, including RDFa, Microdata and JSON-LD.",
		"post_date": "2015-07-10 17:39:35",
		"url": "http://schema.org/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/schema-org-logo.jpeg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Definitions"
		]
	},
	{
		"tool_id": "eYiK3pS7TRL6116EdvrvG116ZSrhfv2dzHvZGU5KUWHToVDrS123YqtY9hJVPenjiKln07eBxh1skz84da40qoqeRTfA117117",
		"name": "Siren",
		"user": "",
		"details": "Siren is a hypermedia specification for representing entities. As HTML is used for visually representing documents on a Web site, Siren is a specification for presenting entities via a Web API. Siren offers structures to communicate information about entities, actions for executing state transitions, and links for client navigation.",
		"post_date": "2014-12-19 10:54:55",
		"url": "",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/kevin-swiber.jpeg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Media Type",
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "IOgNZxaFF116sgf123fwlamR4Vg7Vvz7u5116I3knrjGxconiR116XRgl00EleMV88ZkdipsUcempj116NEFy700D81ECUMg117117",
		"name": "snowcrash",
		"user": "apiaryio",
		"details": "Snow Crash is the reference&nbsp;API Blueprint&nbsp;parser built on top of the&nbsp;Sundown&nbsp;Markdown parser.",
		"post_date": "2015-05-14 12:42:39",
		"url": "https://github.com/apiaryio/snowcrash/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/bw-api-blueprint-icon.png",
		"forks": "42",
		"followers": "265",
		"watchers": "265",
		"tags": [
			"Parser",
			"GitHub",
			"Definitions",
			"API Blueprint Core",
			"API Blueprint"
		]
	},
	{
		"tool_id": "rs2Cy1116nW6S4m1237FFZqnlL3aJtNmnSo123Nbpf6eKb4N116tt6jAnjHrOiQS51qgU123gkUbK4SYeJPyW2v1ZD7a5SJg117117",
		"name": "Swagger2RAML",
		"user": "",
		"details": "A utility to generate RAML documentation from Swagger JSON.",
		"post_date": "2014-06-15 13:09:11",
		"url": "https://github.com/8x8Cloud/swagger2raml",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/raml-logo.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Swagger",
			"Definitions",
			"Converter"
		]
	},
	{
		"tool_id": "9WomN7BhvN3LLo95116S105Rk116RDC7uyilxQXW4XAWuYxZbuo1160sqtP9afwrDgjKYmoLUwpyTj1B0116A84123NPoanA117117",
		"name": "UBER",
		"user": "",
		"details": "The Uber message format is a minimal read/write hypermedia type designed to support simple state transfers and ad-hoc hypermedia-based transitions. This document describes both the XML and JSON variants of the format and provides guidelines for supporting Uber messages over the HTTP protocol.",
		"post_date": "2014-07-25 18:05:16",
		"url": "https://rawgit.com/mamund/media-types/master/uber-hypermedia.html",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "http://twitter.com/uberhypermedia ",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/blog/madmen_icon_400x400.jpg",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Hypermedia",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "J2ljRQEWSDd92YjRYKb2txIqKhxhh4FzBfz3uilwje4DN90rCyiLB6eKXWpDa6NeHQpquqlF83ZB3Wdi0EnvCg117117",
		"name": "Web Application Description Language (WADL)",
		"user": "",
		"details": "The Web Application Description Language (WADL) is a machine-readable XML description of HTTP-based web applications (typically REST web services). WADL models the resources provided by a service and the relationships between them. WADL is intended to simplify the reuse of web services that are based on the existing HTTP architecture of the Web. It is platform and language independent and aims to promote reuse of applications beyond the basic use in a web browser.",
		"post_date": "2015-07-11 16:36:02",
		"url": "https://wadl.java.net/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wadl-icon.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "5IRX49oA1WFOOq39I1kP3A11TqOT4DnwtQgDtAO5RzKGCLrTnqQmwe2tC7spV34Aw9xFSffpI116O19UO0943kZQ117117",
		"name": "Web Resource Modeling Language (WRML)",
		"user": "wrml",
		"details": "WRML, the Web Resource Modeling Language, is a domain-specific modeling language thats oriented toward the design of REST APIs.",
		"post_date": "2016-03-11 22:25:09",
		"url": "http://tool.api.kinlane.com/tool/fromgithub/",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wrml-logo.png",
		"forks": "7",
		"followers": "13",
		"watchers": "13",
		"tags": [
			"Specification",
			"GitHub",
			"Design",
			"Definitions"
		]
	},
	{
		"tool_id": "p5BtkXPjm123rSHmmKD3LsSLNLGr80ZAJuVtUkmY1238bkxbj3Cgkfor6Dnq91234CeFxBuLSLnwzF9fmzT0gO51On2A117117",
		"name": "Web Services Description Language (WSDL)",
		"user": "",
		"details": "WSDL is an XML format for describing network services as a set of endpoints operating on messages containing either document-oriented or procedure-oriented information. The operations and messages are described abstractly, and then bound to a concrete network protocol and message format to define an endpoint. Related concrete endpoints are combined into abstract endpoints (services). WSDL is extensible to allow description of endpoints and their messages regardless of what message formats or network protocols are used to communicate, however, the only bindings described in this document describe how to use WSDL in conjunction with SOAP 1.1, HTTP GET/POST, and MIME.",
		"post_date": "2015-07-11 16:31:23",
		"url": "http://www.w3.org/TR/wsdl",
		"blog_url": "",
		"blog_rss_url": "",
		"twitter_url": "",
		"github_url": "",
		"logo": "http://kinlane-productions.s3.amazonaws.com/api-evangelist-site/tool/wsdl-icon.png",
		"forks": 0,
		"followers": 0,
		"watchers": 0,
		"tags": [
			"Specification",
			"Design",
			"Definitions"
		]
	}
]